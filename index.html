<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tokenizer Tool</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        .tabcontent {
            transition: opacity 0.3s ease;
        }

        .tabcontent.hidden {
            opacity: 0;
            display: none;
        }

        .tabcontent:not(.hidden) {
            opacity: 1;
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        textarea:focus,
        input:focus {
            outline: none;
            ring: 2px;
        }
    </style>
</head>

<body class="bg-gray-50 font-sans min-h-screen flex items-center justify-center p-4">
    <div class="container max-w-3xl mx-auto p-6 bg-white rounded-xl shadow-2xl">
        <h1 class="text-3xl md:text-4xl font-bold text-center text-gray-900 mb-8">Tokenizer Tool</h1>

        <!-- Tabs -->
        <div class="border-b border-gray-200 mb-6">
            <nav class="flex space-x-4 justify-center">
                <button id="customTab"
                    class="tablinks py-3 px-6 text-base font-semibold text-blue-600 border-b-3 border-blue-600 transition-colors duration-200"
                    onclick="openTab('custom')">Custom Tokenizer</button>
                <button id="charTab"
                    class="tablinks py-3 px-6 text-base font-semibold text-gray-500 hover:text-blue-600 hover:border-blue-600 border-b-3 border-transparent transition-colors duration-200"
                    onclick="openTab('char')">Character Tokenizer</button>
            </nav>
        </div>

        <!-- Custom Tokenizer Tab -->
        <div id="custom" class="tabcontent">
            <label for="customInputText" class="block text-sm font-medium text-gray-700 mb-2">Text to Encode</label>
            <textarea id="customInputText" rows="5"
                class="block w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition duration-150"
                placeholder="Enter text to encode..."></textarea>

            <label for="customTokensInput" class="block mt-6 text-sm font-medium text-gray-700 mb-2">Tokens to
                Decode</label>
            <input id="customTokensInput" type="text"
                class="block w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition duration-150"
                placeholder="e.g., 98,97,96,95,94">

            <div class="mt-6 flex space-x-3">
                <button onclick="encode('custom')"
                    class="flex-1 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition duration-200 disabled:bg-blue-400">Encode</button>
                <button onclick="decode('custom')"
                    class="flex-1 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition duration-200 disabled:bg-blue-400">Decode</button>
            </div>

            <div id="customOutput"
                class="mt-6 p-4 bg-gray-100 border border-gray-200 rounded-lg text-gray-800 font-mono text-sm"></div>
        </div>

        <!-- Character Tokenizer Tab -->
        <div id="char" class="tabcontent hidden">
            <label for="charInputText" class="block text-sm font-medium text-gray-700 mb-2">Text to Encode</label>
            <textarea id="charInputText" rows="5"
                class="block w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition duration-150"
                placeholder="Enter text to encode..."></textarea>

            <label for="charTokensInput" class="block mt-6 text-sm font-medium text-gray-700 mb-2">Tokens to
                Decode</label>
            <input id="charTokensInput" type="text"
                class="block w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition duration-150"
                placeholder="e.g., 1,2,3,4,5">

            <div class="mt-6 flex space-x-3">
                <button onclick="encode('char')"
                    class="flex-1 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition duration-200 disabled:bg-blue-400">Encode</button>
                <button onclick="decode('char')"
                    class="flex-1 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition duration-200 disabled:bg-blue-400">Decode</button>
            </div>

            <div id="charOutput"
                class="mt-6 p-4 bg-gray-100 border border-gray-200 rounded-lg text-gray-800 font-mono text-sm"></div>
        </div>
    </div>

    <script>
        // Custom Tokenizer
        const CustomTokenizer = {
            vocab: {},
            reverseVocab: {},

            init() {
                const letterMap = {
                    'a': 98, 'b': 97, 'c': 96, 'd': 95, 'e': 94, 'f': 93, 'g': 92, 'h': 91,
                    'i': 90, 'j': 89, 'k': 88, 'l': 87, 'm': 86, 'n': 85, 'o': 84, 'p': 83,
                    'q': 82, 'r': 81, 's': 80, 't': 79, 'u': 78, 'v': 77, 'x': 76, 'y': 75,
                    'z': 73, 'w': 74
                };
                const specialChars = ['!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '=', '\\', '|'];
                let nextId = 100;

                this.vocab['<PAD>'] = 0;
                this.reverseVocab[0] = '<PAD>';
                this.vocab['<UNK>'] = 1;
                this.reverseVocab[1] = '<UNK>';

                for (const [char, id] of Object.entries(letterMap)) {
                    this.vocab[char] = id;
                    this.reverseVocab[id] = char;
                }

                for (const char of specialChars) {
                    this.vocab[char] = nextId;
                    this.reverseVocab[nextId] = char;
                    nextId++;
                }
            },

            encode(text) {
                if (!text || typeof text !== 'string') return [];
                return text.toLowerCase().split('').map(char =>
                    this.vocab[char] || this.vocab['<UNK>']
                );
            },

            decode(tokens) {
                if (!Array.isArray(tokens)) return '';
                return tokens.map(token => this.reverseVocab[token] || '<UNK>').join('');
            },

            getVocabQuality(text) {
                const vocabSize = Object.keys(this.vocab).length;
                if (!text || typeof text !== 'string') {
                    return `Vocabulary Size: ${vocabSize}\nCoverage: N/A (no input text)`;
                }
                const chars = new Set(text.toLowerCase().split(''));
                const knownChars = [...chars].filter(char => char in this.vocab).length;
                const coverage = ((knownChars / chars.size) * 100).toFixed(2);
                return `Vocabulary Size: ${vocabSize}\nCoverage: ${coverage}% (${knownChars}/${chars.size} characters known)`;
            }
        };

        // Character Tokenizer
        const CharTokenizer = {
            vocab: {},
            reverseVocab: {},
            nextTokenId: 1,

            init() {
                const chars = 'abcdefghijklmnopqrstuvwxyz0123456789 .,!?';
                for (let char of chars) {
                    this.vocab[char] = this.nextTokenId;
                    this.reverseVocab[this.nextTokenId] = char;
                    this.nextTokenId++;
                }
                this.vocab['<PAD>'] = 0;
                this.reverseVocab[0] = '<PAD>';
                this.vocab['<UNK>'] = this.nextTokenId;
                this.reverseVocab[this.nextTokenId] = '<UNK>';
                this.nextTokenId++;
            },

            encode(text) {
                if (!text || typeof text !== 'string') return [];
                return text.toLowerCase().split('').map(char =>
                    this.vocab[char] || this.vocab['<UNK>']
                );
            },

            decode(tokens) {
                if (!Array.isArray(tokens)) return '';
                return tokens.map(token => this.reverseVocab[token] || '<UNK>').join('');
            },

            getVocabQuality(text) {
                const vocabSize = Object.keys(this.vocab).length;
                if (!text || typeof text !== 'string') {
                    return `Vocabulary Size: ${vocabSize}\nCoverage: N/A (no input text)`;
                }
                const chars = new Set(text.toLowerCase().split(''));
                const knownChars = [...chars].filter(char => char in this.vocab).length;
                const coverage = ((knownChars / chars.size) * 100).toFixed(2);
                return `Vocabulary Size: ${vocabSize}\nCoverage: ${coverage}% (${knownChars}/${chars.size} characters known)`;
            }
        };

        CustomTokenizer.init();
        CharTokenizer.init();

        function openTab(tabName) {
            const tabcontents = document.getElementsByClassName('tabcontent');
            for (let i = 0; i < tabcontents.length; i++) {
                tabcontents[i].classList.add('hidden');
            }
            const tablinks = document.getElementsByClassName('tablinks');
            for (let i = 0; i < tablinks.length; i++) {
                tablinks[i].classList.remove('text-blue-600', 'border-blue-600');
                tablinks[i].classList.add('text-gray-500', 'border-transparent', 'hover:text-blue-600', 'hover:border-blue-600');
            }
            document.getElementById(tabName).classList.remove('hidden');
            document.getElementById(`${tabName}Tab`).classList.remove('text-gray-500', 'border-transparent', 'hover:text-blue-600', 'hover:border-blue-600');
            document.getElementById(`${tabName}Tab`).classList.add('text-blue-600', 'border-blue-600');
        }

        async function encode(type) {
            const button = event.currentTarget;
            button.disabled = true;
            const tokenizer = type === 'custom' ? CustomTokenizer : CharTokenizer;
            const inputText = document.getElementById(`${type}InputText`).value;
            const tokens = tokenizer.encode(inputText);
            const quality = tokenizer.getVocabQuality(inputText);
            document.getElementById(`${type}Output`).innerText = `Tokens: [${tokens.join(', ')}]\n${quality}`;
            await new Promise(resolve => setTimeout(resolve, 300)); // Simulate processing
            button.disabled = false;
        }

        async function decode(type) {
            const button = event.currentTarget;
            button.disabled = true;
            const tokenizer = type === 'custom' ? CustomTokenizer : CharTokenizer;
            const tokensInput = document.getElementById(`${type}TokensInput`).value
                .split(',')
                .map(t => parseInt(t.trim()))
                .filter(t => !isNaN(t));
            const text = tokenizer.decode(tokensInput);
            const quality = tokenizer.getVocabQuality('');
            document.getElementById(`${type}Output`).innerText = `Text: ${text}\n${quality}`;
            await new Promise(resolve => setTimeout(resolve, 300)); // Simulate processing
            button.disabled = false;
        }
    </script>
</body>

</html>